import{_ as d,c as e,o,ag as c}from"./chunks/framework.CA5djfbr.js";const r="/Tutorial/images/docker_1.png",u=JSON.parse('{"title":"Docker 基础笔记","description":"","frontmatter":{},"headers":[],"relativePath":"tutorial/Docker/note.md","filePath":"tutorial/Docker/note.md","lastUpdated":1761009797000}'),a={name:"tutorial/Docker/note.md"};function n(i,t,l,h,s,m){return o(),e("div",null,[...t[0]||(t[0]=[c('<h1 id="docker-基础笔记" tabindex="-1">Docker 基础笔记 <a class="header-anchor" href="#docker-基础笔记" aria-label="Permalink to &quot;Docker 基础笔记&quot;">​</a></h1><h2 id="docker-安装" tabindex="-1">docker 安装 <a class="header-anchor" href="#docker-安装" aria-label="Permalink to &quot;docker 安装&quot;">​</a></h2><p>官网安装教程: <a href="https://docs.docker.com/engine/install/" target="_blank" rel="noreferrer">https://docs.docker.com/engine/install/</a></p><p>选择自己的系统进行安装</p><p>学会常用 <code>--help</code> 获取信息</p><h2 id="常见命令" tabindex="-1">常见命令 <a class="header-anchor" href="#常见命令" aria-label="Permalink to &quot;常见命令&quot;">​</a></h2><p>需要区分<code>镜像</code>和<code>容器</code>的概念 <code>镜像</code>: 一个模具,一个 docker 中不会有 2 个一模一样的镜像 <code>容器</code>: 使用镜像这个模具制作的东西,可以有很多功能一样的容器,但每个容器都有自己的属性</p><p><img src="'+r+'" alt="命令总结" loading="lazy"></p><h3 id="镜像命令" tabindex="-1">镜像命令 <a class="header-anchor" href="#镜像命令" aria-label="Permalink to &quot;镜像命令&quot;">​</a></h3><table tabindex="0"><thead><tr><th>命令</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>docker search</code></td><td>搜索<a href="https://hub.docker.com/" target="_blank" rel="noreferrer">镜像市场</a></td><td><code>OFFICIAL</code>带<code>[OK]</code>的是官方镜像</td></tr><tr><td><code>docker pull</code></td><td>下载镜像</td><td><code>docker pull nginx</code>: 默认下载最新版<br><code>docker pull nginx:1.26.0</code>: 下载指定版本</td></tr><tr><td><code>docker images</code></td><td>已下载镜像列表</td><td><code>docker images</code>或<code>docker image ls</code></td></tr><tr><td><code>docker rmi</code></td><td>删除镜像</td><td><code>docker rmi -f nginx</code>强制删除</td></tr></tbody></table><h3 id="容器命令" tabindex="-1">容器命令 <a class="header-anchor" href="#容器命令" aria-label="Permalink to &quot;容器命令&quot;">​</a></h3><table tabindex="0"><thead><tr><th>命令</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>docker run</code></td><td>使用镜像启动容器</td><td><code>docker run nginx</code> 如果没有这个镜像就会自动下载,而且会阻死控制台</td></tr><tr><td><code>docker ps</code></td><td>正在运行的容器</td><td><code>docker ps -a</code> 运行和停止的容器</td></tr><tr><td><code>docker start</code></td><td>启动容器</td><td>可以使用容器的名字<code>NAMES</code>或者 id<code>CONTAINER ID</code>(可以只写前 3 位)</td></tr><tr><td><code>docker stop</code></td><td>停止容器</td><td>使用方法同上</td></tr><tr><td><code>docker restart</code></td><td>重启容器</td><td>使用方法同上</td></tr><tr><td><code>docker stats</code></td><td>容器资源占用</td><td>可查看实时 cpu,内存,网络,IO,使用方法同上</td></tr><tr><td><code>docker logs</code></td><td>容器运行日志</td><td>使用方法同上</td></tr><tr><td><code>docker exec</code></td><td>进入容器文件系统</td><td>使用方法同上</td></tr><tr><td><code>docker rm</code></td><td>删除容器</td><td>先停止再删除,也可以<code>docker rm -f 58e</code>强制删除<br>删除所有状态的容器: `docker rm -f $(docker ps -aq)``</td></tr></tbody></table><p><strong>重点</strong></p><p><code>docke run -d -p 88:80 --name mynginx nginx</code></p><ul><li><code>-d</code>: 后台启动</li><li><code>-p 88:80</code>: 端口映射,访问主机的 88 端口就是访问容器的 80 端口</li><li><code>--name mynginx</code>: 给容器取名为 mynginx</li></ul><p><code>docker exec -it mynginx /bin/bash</code></p><ul><li><code>-it</code>: 交互模式</li><li><code>mynginx</code>: 使用容器名称进入容器的文件系统,也可以使用 id</li><li><code>/bin/bash</code>: 使用 bash 命令行,可以简写为 <code>bash</code></li></ul><blockquote><p>修改 nginx 默认页面内容,可以进入<code>/usr/share/nginx/html</code>中修改<code>index.html</code>的内容.<br> 容器内的系统非常轻量化,很多基本的命令都没有</p></blockquote><h3 id="保存镜像" tabindex="-1">保存镜像 <a class="header-anchor" href="#保存镜像" aria-label="Permalink to &quot;保存镜像&quot;">​</a></h3><table tabindex="0"><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>docker commit</code></td><td>提交,将容器制作成镜像</td></tr><tr><td><code>docker save</code></td><td>保存,将镜像打包为文件</td></tr><tr><td><code>docker load</code></td><td>加载,加载镜像文件</td></tr></tbody></table><p><strong><code>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</code>: 将容器制作成镜像</strong></p><table tabindex="0"><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-a</code></td><td>--author string 作者（例如，“John Hannibal Smith <a href="mailto:hannibal@a-team.com" target="_blank" rel="noreferrer">hannibal@a-team.com</a>”）</td></tr><tr><td><code>-c</code> <code>--change list</code></td><td>将 Dockerfile 指令应用于创建的镜像</td></tr><tr><td><code>-m</code> <code>--message string</code></td><td>提交消息</td></tr><tr><td><code>-p</code> <code>--pause</code></td><td>在提交期间暂停容器（默认为 true）</td></tr></tbody></table><ul><li>例如: <code>docker commit -m &#39;updata index.html&#39; mynginx mynginx:v1.0</code><ul><li><code>-m &#39;updata index.html&#39;</code>: 提交的消息</li><li><code>mynginx</code>: 容器名称,也可以使用 id</li><li><code>mynginx:v1.0</code>: 想要做成的镜像名称</li></ul></li></ul><p><strong><code>docker save [OPTIONS] IMAGE [IMAGE...]</code>: 将镜像打包为文件</strong></p><table tabindex="0"><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-o</code>, <code>--output string</code></td><td>写入文件，而不是 STDOUT</td></tr><tr><td><code>--platform string</code></td><td>仅保存给定的平台变体。格式为 “os[/arch[/variant]]” （例如，“linux/amd64”）</td></tr></tbody></table><ul><li>例如: <code>docker save -o mynginx.tar mynginx:v1.0</code><ul><li><code>-o mynginx.tar</code>: 保存为<code>mynginx.tar</code>文件</li><li><code>mynginx:v1.0</code>: 需要被保存的镜像</li></ul></li></ul><p><strong><code>docker load [OPTIONS]</code>: 加载镜像文件</strong></p><table tabindex="0"><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-i</code>, <code>--input string</code></td><td>从 tar 存档文件读取，而不是 STDIN</td></tr><tr><td><code>--platform string</code></td><td>仅加载给定的平台变体。格式为 “os[/arch[/variant]]” （例如，“linux/amd64”）</td></tr><tr><td><code>-q</code>, <code>--quiet</code></td><td>抑制负载输出</td></tr></tbody></table><ul><li>例如: <code>docker load -i mynginx.tar</code><ul><li><code>-i mynginx.tar</code>: 加载指定的 mynginx.tar 包</li></ul></li></ul><h3 id="分享社区" tabindex="-1">分享社区 <a class="header-anchor" href="#分享社区" aria-label="Permalink to &quot;分享社区&quot;">​</a></h3><p>官网:<a href="https://www.docker.com/" target="_blank" rel="noreferrer">https://www.docker.com/</a></p><table tabindex="0"><thead><tr><th>命令</th><th>说明</th><th>用法</th></tr></thead><tbody><tr><td><code>docker login</code></td><td>登录</td><td><code>docker login -u &lt;username&gt;</code></td></tr><tr><td><code>docker tag</code></td><td>命名</td><td><code>docker tag 原镜像名 目标镜像名</code>(记得加版本号)</td></tr><tr><td><code>docker push</code></td><td>推送</td><td><code>docker push [OPTIONS] NAME[:TAG]</code></td></tr></tbody></table><h2 id="存储" tabindex="-1">存储 <a class="header-anchor" href="#存储" aria-label="Permalink to &quot;存储&quot;">​</a></h2><p>容器运行时有自己的文件系统和环境,在容器里面修改或增加文件并不方便,而且一旦销毁容器,里面的数据也会消失,所以需要将主机的文件和容器的文件进行一种关联,操作主机的文件也就能操作容器的文件</p><h3 id="目录挂载" tabindex="-1">目录挂载 <a class="header-anchor" href="#目录挂载" aria-label="Permalink to &quot;目录挂载&quot;">​</a></h3><p><code>-v ~/app/nghtml:/usr/share/nginx/html</code></p><ul><li>完整用法: <code>docke run -d -p 88:80 -v ~/app/nghtml:/usr/share/nginx/html --name mynginx nginx</code></li><li>在启动时,增加挂载参数,使主机的<code>~/app/nghtml</code>和<code>/usr/share/nginx/html</code>形成关联,修改任何一个都会使另一个同步改变</li><li>如果主机没有<code>~/app/nghtml</code>文件夹会自动创建,并且容器中的<code>/usr/share/nginx/html</code>文件夹也是空的</li><li>不适用于需要默认配置启动的容器,因为挂载会清除所有原的数据,以空文件夹开始</li></ul><h3 id="卷映射" tabindex="-1">卷映射 <a class="header-anchor" href="#卷映射" aria-label="Permalink to &quot;卷映射&quot;">​</a></h3><p><code>-v ngconf:/etc/nginx</code></p><ul><li>完整用法: <code>docker run -d -p 88:80 -v ngconf:/etc/nginx --name mynginx nginx</code></li><li><code>ngconf</code> 自定义的卷名,不是文件夹,启动后会与<code>/etc/nginx</code>里的初始配置一致,修改任何一个都会使另一个同步改变</li><li>自定义的卷统一在 <code>var/lib/docker/volumes/&lt;volume-name&gt;</code>目录下</li><li><code>docker volume ls</code> 列出所有卷</li><li><code>docker volume creat &lt;name&gt;</code> 创建一个卷</li><li><code>docker volume inspect &lt;name&gt;</code> 查看一个卷的详情</li></ul><h2 id="网络" tabindex="-1">网络 <a class="header-anchor" href="#网络" aria-label="Permalink to &quot;网络&quot;">​</a></h2><h3 id="docker-ip-访问" tabindex="-1">docker ip 访问 <a class="header-anchor" href="#docker-ip-访问" aria-label="Permalink to &quot;docker ip 访问&quot;">​</a></h3><ul><li>每个 docker 容器启动都会加入 docker 的默认网络<code>docker0</code>,使用 <code>ip a</code>查看所有网络</li><li><code>docker container inspect &lt;name&gt;</code> 或者 <code>docker inspect &lt;name&gt;</code>可以查看一个容器的细节,其中<code>IPAddress</code>就是这个容器的 ip 地址,容器和容器之间可以通过对方的这个 ip+容器端口进行数据互访</li><li>但是这种方法 ip 可能会变化</li></ul><h3 id="自定义网络" tabindex="-1">自定义网络 <a class="header-anchor" href="#自定义网络" aria-label="Permalink to &quot;自定义网络&quot;">​</a></h3><ul><li><code>docker0</code> 不支持主机域名,需要自定义一个网络,容器启动加入这个网络,容器的名称就是稳定的域名</li><li><code>docker network &lt;COMMAND&gt;</code><table tabindex="0"><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>connect</code></td><td>Connect a container(容器) to a network</td></tr><tr><td><code>create</code></td><td>Create a network</td></tr><tr><td><code>disconnect</code></td><td>Disconnect a container from a network</td></tr><tr><td><code>inspect</code></td><td>Display(显示) detailed(详细) information(信息) on one or more networks</td></tr><tr><td><code>ls</code></td><td>List networks</td></tr><tr><td><code>prune</code>(修剪)</td><td>Remove all unused(未使用) networks</td></tr><tr><td><code>rm</code></td><td>Remove one or more networks</td></tr></tbody></table></li><li><code>docker network creat mynet</code> 创建名为<code>mynet</code>的自定义网络</li><li><code>docker run -d -p 88:80 --network mynet --name mynginx nginx</code> 使用自定义网络启动容器,同一个网络中的其他容器应用就可以通过<code>http://mynginx:80</code>访问这个容器应用了</li></ul>',45)])])}const p=d(a,[["render",n]]);export{u as __pageData,p as default};
